# Exploitable Server

## WARNING 
**This project is VULNERABLE to many exploits on purpose!  Please be sure to play with it locally - don't deploy it to a publicly accessible site like Heroku.**

## How to Set Up
1. ```git clone``` this repository to a local machine (that is not publicly reachable).
2. Navigate into the folder ```exploitable/mysql``` and run ```npm install```.
3. (One-time setup step) From MySQL workbench, run the code enclosed in ```database/schema.sql``` (first) and ```database/seeds.sql``` (second). 
4. Next, create a blank file called ```.env``` in the root directory and input your own database information in this exact format. (No extra "" required!)
```
DB_HOST=localhost
DB_USER=yourusernamehere
DB_PASS=yourpasswordhere
DB_PORT=yourporthere
DB_DATABASE=exploitable
```
5. Run the server from the command line via ```node server.js```

## Example Exploits
1. Script injection examples
    A. Direct injection 
    B. HTML escape injection 
    C. Injection via Postman
    D. Best practices
2. SQL injection examples
    A. Injection via form
    B. Injection via Postman
    C. Best practices
3. Password Management Concerns

## 1. Script Injection Examples
A common problem developers face is folks trying to sneak their own scripts into a webpage. This can happen when a server accepts input from users and then plops it onto a page directly as html. Since a ```<script>``` tag is html...that means that most clients will then run that script for anyone who visits a compromised page!  There are all kinds of malicious things that rogue scripts can do, including hijacking the browser, stealing data, etc.

The following examples are exploits you can try out yourself to see how they work on this vulnerable server. Try to figure out what might be causing them!

### A. Direct Injection Example
**Steps to Reproduce:**
1. Navigate to the /signup.html page.
2. Note the two fields which advertise that they will be 'visible to all users'.
3. In the "Full Name" field, input ```<script>alert("Hacked from Fullname!");</script>```
4. Submit the form
5. Navigate to the main page (/index.html). What do you see?

### B. Injection via HTML Escape Example
**Steps to Reproduce:**
1. Navigate to the /signup.html page.
2. Note the two fields which advertise that they will be 'visible to all users'.
3. In the "email" field, input ```"> <script>alert("Hacked from Email");</script>```
4. Submit the form
5. Navigate to the main page (/index.html). What do you see?

### C. Injection via Postman
**Steps to Reproduce:**
1. Open Postman.
2. Create a new POST request to "localhost:PORT/api/users". (Be sure to swap in your PORT!) 
3. Click the 'Body' tab and choose 'Raw', then make sure the drop down says 'JSON'.
4. Copy and paste the below JSON into Postman, then click "Send".
```
{
"username": "badhorse",
"email": "evil@evil.com",
"fullname": "<script>alert('Hacked from Postman');</script>",
"address": "123 Sesame Street",
"city": "Seattle",
"org": "Bad Horse",
"password": "worsepassword",
"state": "WA"
}
```
5. Navigate to the main page (/index.html). What do you see?
![Visual Guide](postman-newuser.png)

### D. Best Practices 
* Avoid concatenating HTML together directly in a webpage. Instead, create elements and set text in text nodes.
Ex: use jQuery's method ```$("<p>").text(stringFromUser);``` to create a paragraph element and set its text.
* Always validate the input you receive from users on both the front AND the back end!  (Remember: folks could always hit your server directly with Postman). It helps cut down on exploits if you try to check that what a user is putting in is valid :)
* [More resources about preventing various types of script injections](https://www.owasp.org/index.php/Cross-site_Scripting_(XSS))

## 2. SQL Injection Examples
SQL injection happens when folks try to send malicious SQL instructions to your backend database. This can happen when an application accepts data from users and plops it directly into a SQL statement. Malicious commands can result in data being exposed, modified, or destroyed -- very bad news!

### A. Injection via Form
**Steps to Reproduce:**
1. Navigate to the login page (/login.html).
2. First, see what the page is supposed to do! Input "barbaz" as the username and "abc" as the password. Result: you see user info for just one person, as expected.
3. Now, try entering the following into the 'password' field: 
```
" OR ""="
```
4. Scroll down. What happened?

**Explanation:**
1. This form sends the username and password via a POST request to a backend route, /login. 
2. The user's data is then pasted into the following string:

```SELECT * FROM users WHERE username="${req.body.username}" AND password="${req.body.password}"```

(NOTE: this is identical to using the + to concatenate strings:
```'SELECT * FROM users WHERE username="' + req.body.username + '" AND password="' + req.body.password + '"'```)
3. Think about what happens if we are pasting ```" OR ""="``` into 'password' here. It will look like this:
```SELECT * FROM users WHERE username="evilevil" AND password="" OR ""=""```
4. Because ```""=""``` evaluates to TRUE, the db will run SELECT * for every row.


### B. THIS SAME ATTACK can also be performed by Postman!
**Steps to Reproduce**
1. Open Postman.
2. Create a new POST request to "localhost:PORT/login". (Be sure to swap in your PORT!) 
3. Click the 'Body' tab and choose 'Raw', then make sure the drop down says 'JSON'.
4. Copy and paste the below JSON into Postman, then click "Send".
```
{
"username": "evilevil",
"password": "\" OR \"\"=\""
}
```

### C. Best Practices
* Never concatenate SQL statements together in a string directly! Most packages (including node's 'mysql' package) provide options for 'parameterizing' statements -- you make a template string with ? and ?? where values should go. The SQL engine will then perform checks to make sure that the stuff you want to put in the ? and ?? are valid for that part of the statement.    
* Again, it's also a best practice to validate data you are getting on both the front and the back end too.
* [Some more examples from W3Schools](https://www.w3schools.com/sql/sql_injection.asp)

## 3. Password Management Concerns

One serious problem with this server is that passwords are being stored in plain text! This is a HUGE issue because it means a user's account isn't just vulnerable to external folks trying to get into your database -- it also means that developers can easily see the passwords whenever they query the db. (All it would take is one bad apple at your company to steal or leak a customer's password!) Never **ever** save a password in plain text. 

Additionally, security is a tough space!  While it may be tempting to write your own hashing or encryption, most folks end up with holes in their algorithms that are hard to spot. Instead, it's always advisable to stand on the shoulders of giants and use industry-standard tools.

* The most commonly recommended package for handling user auth is [Passport.js](http://www.passportjs.org/). It supports both traditional username and password storage (backed by bcrypt) as well as third-party auth like Login with Google. 

* This article provides a bit more information about passwords and some of the difficulties dealing with them: [How (not to) store passwords](https://itnext.io/how-not-to-store-passwords-4955569e6e84)